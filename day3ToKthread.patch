diff --git a/drivers/misc/example.c b/drivers/misc/example.c
index cb7be87cc70f..7ed595341509 100644
--- a/drivers/misc/example.c
+++ b/drivers/misc/example.c
@@ -1,6 +1,7 @@
 #include <linux/errno.h>
 #include <linux/slab.h>
 #include <linux/gfp.h>
+#include <linux/types.h>
 #include "example.h"
 
 int misc_example_add(int left, int right)
@@ -48,3 +49,20 @@ int char_arr_cmp(const char* s1,const char* s2)
     return *(const unsigned char*)s1-*(const unsigned char*)s2;
 }
 
+
+int thread_func(void *data){
+    int *n;
+    n = (int *)data;
+    int i = 0;
+    while(i < 10){
+	*n = *n + 1;
+        printk("%d\n", *n);
+        i++;
+    }
+    //*n = 20;
+    return 0;
+    //do_exit();
+}
+
+
+
diff --git a/drivers/misc/example.h b/drivers/misc/example.h
index 7cbbc2b2c99a..08d19a4e5596 100644
--- a/drivers/misc/example.h
+++ b/drivers/misc/example.h
@@ -5,3 +5,5 @@ int char_arr_cmp(const char* s1, const char* s2);
 char* print_char_input(char* input);//char* is almost the same as char[]
 int compare_kalloc(void* km1, void* km2);
 int compare_pages(struct page* p1,struct page* p2);
+int thread_func(void *data);
+int thread_atomic(void *data);
diff --git a/drivers/misc/example_test.c b/drivers/misc/example_test.c
index d2a69183fad9..1f791d3f18e5 100644
--- a/drivers/misc/example_test.c
+++ b/drivers/misc/example_test.c
@@ -2,6 +2,10 @@
 #include <linux/slab.h>
 #include <linux/gfp.h>
 #include <linux/highmem.h>
+#include <linux/kthread.h>
+#include <linux/semaphore.h>
+#include <linux/spinlock_types.h>
+#include <linux/delay.h>
 #include "example.h"
 
 	/* Define the test cases. */
@@ -160,6 +164,191 @@ static void test_compare_pages_in_order4(struct kunit *test)
 	KUNIT_EXPECT_EQ(test, 0, compare_pages(p1,p2));
 }
 
+static void test_compare_pages_in_order5(struct kunit *test)
+{
+	struct page *pages = alloc_pages(GFP_KERNEL,1);
+	struct page *p1 = kmap_to_page(&pages[0]);// without this line there will be a mm error!
+	//struct page *px;
+	//px = kmap_to_page(&pages[1]);
+	struct list_head *lh = &p1->lru;
+	struct list_head *nh = lh->next;
+	//struct list_head *lh = p2->lru.next;
+
+	struct page *p2;
+	p2 = container_of(nh, struct page, lru);
+	KUNIT_EXPECT_EQ(test, 0, compare_pages(p1,p2));
+}
+
+
+
+static void test_mainthread(struct kunit *test){
+    struct task_struct *task1;
+    //struct task_struct *task2;
+    void* k1 = kmalloc(4, GFP_KERNEL);
+    int var = 10;
+    k1 = &var;
+    //https://stackoverflow.com/questions/22469233/global-variable-wont-change-in-other-thread-in-c
+    //task1 = kthread_run(&thread_func, k1, "thread_func_1");
+    //kthread_stop(task1);
+    thread_func(k1);
+    int *rst;
+    rst = (int *)k1;
+    KUNIT_EXPECT_EQ(test, 20, *rst);
+}
+static struct semaphore sem;
+int thread_atomic(void *data){
+    int *d;
+    d = (int *)data;
+    atomic_t n = ATOMIC_INIT(*d);
+    int i = 0;
+    while(i < 10){
+	atomic_inc(&n);
+        i++;
+    }
+    *d = atomic_read(&n);
+    printk("inside atomic : %d\n", *d);
+    //*n = 20;
+    up(&sem);
+    return 0;
+    //do_exit();
+}
+int thread_funct(void *data){
+    int *n;
+    n = (int *)data;
+    int i = 0;
+    while(i < 10){
+	*n = *n + 1;
+        printk("%d\n", *n);
+        i++;
+    }
+    //*n = 20;
+    up(&sem);
+    return 0;
+    //do_exit();
+}
+
+static void test_kthread(struct kunit *test){
+    printk("Module starting ... ... ..\n");
+    printk("Module starting kthread test... ... ..\n");
+    struct task_struct *task1;
+    //struct task_struct *task2;
+    void* k1 = kmalloc(4, GFP_KERNEL);
+    int var = 10;
+    k1 = &var;
+    sema_init(&sem,0);  
+    //https://stackoverflow.com/questions/22469233/global-variable-wont-change-in-other-thread-in-c
+    //DEFINE_SEMAPHORE(&sem);
+    task1 = kthread_run(&thread_funct, k1, "thread_func_1");
+    down(&sem);// wait until 'up(&sem) in thread_atomic' triggered
+    	       // otherwise, mainthread could finished earlier then kthread
+    //thread_func(k1);
+    int *rst;
+    rst = (int *)k1;
+    kthread_stop(task1);
+    KUNIT_EXPECT_EQ(test, 20, *rst);
+}
+
+static void test_kthread2(struct kunit *test){
+    printk("Module starting ... ... ..\n");
+    printk("Module starting kthread test... ... ..\n");
+    struct task_struct *task1;
+    struct task_struct *task2;
+    void* k1 = kmalloc(4, GFP_KERNEL);
+    void* k2 = kmalloc(4, GFP_KERNEL);
+    int var = 10;
+    int var2 = 10;
+    k1 = &var;
+    k2 = &var2;
+    sema_init(&sem,0);  
+    //https://stackoverflow.com/questions/22469233/global-variable-wont-change-in-other-thread-in-c
+    //DEFINE_SEMAPHORE(&sem);
+    task1 = kthread_run(&thread_funct, k1, "thread_func_1");
+    task2 = kthread_run(&thread_funct, k2, "thread_func_2");
+    down(&sem);// can only down(acquire) when other thread up(release)ed
+    down(&sem);// wait until 'up(&sem) in thread_atomic' triggered
+    	       // otherwise, mainthread could finished earlier then kthread
+    //thread_func(k1);
+    int *rst1;
+    rst1 = (int *)k1;
+    int *rst2;
+    rst2 = (int *)k2;
+    //kthread_stop(task1);
+    //kthread_stop(task2);
+    KUNIT_EXPECT_EQ(test, 20, *rst1);
+    KUNIT_EXPECT_EQ(test, 20, *rst2);
+}
+
+static void test_racethread(struct kunit *test){
+    struct task_struct *task1;
+    //struct task_struct *task2;
+    void* k1 = kmalloc(4, GFP_KERNEL);
+    int var = 10;
+    k1 = &var;
+    task1 = kthread_run(&thread_func, k1, "thread_func_1");
+    //kthread_stop(task1);
+    //thread_func(k1);
+    int *rst;
+    rst = (int *)k1;
+    KUNIT_EXPECT_GT(test, 20, *rst);
+}
+
+
+spinlock_t my_lock;
+DEFINE_SPINLOCK(my_lock);
+
+int thread_func_spl(void *data){
+    spin_lock(&my_lock);
+    int *n;
+    n = (int *)data;
+    int i = 0;
+    while(i < 10){
+	*n = *n + 1;
+        printk("%d\n", *n);
+        i++;
+    }
+    //*n = 20;
+    spin_unlock(&my_lock);
+    return 0;
+    //do_exit();
+}
+
+static void test_splthread(struct kunit *test){
+    struct task_struct *task1;
+    //struct task_struct *task2;
+    void* k1 = kmalloc(4, GFP_KERNEL);
+    int var = 10;
+    k1 = &var;
+    task1 = kthread_run(&thread_func_spl, k1, "thread_func_1");
+    //kthread_stop(task1);
+    //thread_func(k1);
+
+    msleep(1);//explicitly wait fot thread to take lock
+    spin_trylock(&my_lock);
+    int *rst;
+    rst = (int *)k1;
+    spin_unlock(&my_lock);
+    KUNIT_EXPECT_EQ(test, 20, *rst);
+}
+
+static void test_splthread2(struct kunit *test){
+    struct task_struct *task1;
+    struct task_struct *task2;
+    void* k1 = kmalloc(4, GFP_KERNEL);
+    int var = 10;
+    k1 = &var;
+    task1 = kthread_run(&thread_func_spl, k1, "thread_func_1");
+    task2 = kthread_run(&thread_func_spl, k1, "thread_func_2");
+    //kthread_stop(task1);
+    //thread_func(k1);
+
+    msleep(1);//explicitly wait fot thread to take lock
+    spin_trylock(&my_lock);
+    int *rst;
+    rst = (int *)k1;
+    spin_unlock(&my_lock);
+    KUNIT_EXPECT_EQ(test, 30, *rst);
+}
+
 static struct kunit_case misc_example_test_cases[] = {
 	KUNIT_CASE(misc_example_add_test_basic),
 	//KUNIT_CASE(misc_example_test_failure),
@@ -177,9 +366,18 @@ static struct kunit_case misc_example_test_cases[] = {
 	KUNIT_CASE(test_compare_pages_in_order2),
 	KUNIT_CASE(test_compare_pages_in_order3),
 	KUNIT_CASE(test_compare_pages_in_order4),
+	KUNIT_CASE(test_compare_pages_in_order5),
+	KUNIT_CASE(test_mainthread),
+	KUNIT_CASE(test_kthread),
+	KUNIT_CASE(test_kthread2),
+	KUNIT_CASE(test_racethread),
+	KUNIT_CASE(test_splthread),
+	KUNIT_CASE(test_splthread2),
 	{}
 };
 
+
+
 static struct kunit_suite misc_example_test_suite = {
 	.name = "misc-example",
 	.test_cases = misc_example_test_cases,
